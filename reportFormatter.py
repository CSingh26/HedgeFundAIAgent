def _split_for_telegram(full: str):
    chunks = []
    while len(full) > 4000:
        i = full.rfind("\n", 0, 4000)
        if i == -1:
            i = 4000
        chunks.append(full[:i].strip())
        full = full[i:]
    chunks.append(full.strip())
    return chunks

def format_report(analysis, risk):
    """Format the AI hedge fund report neatly for Telegram; returns list of chunks."""
    if "error" in analysis or "error" in risk:
        return ["âš ï¸ Analysis failed due to missing or invalid data."]

    full_report = f"""
ğŸ“Š **AI Hedge Fund Research Report**
------------------------------------

**Symbol:** {analysis.get('symbol', 'N/A')}

**Market & News Analysis:**
{analysis.get('analysis', 'No analysis available')}

**Risk Management Summary:**
{risk.get('risk_report', 'No risk report available')}

------------------------------------
ğŸ’¼ *Generated by your AI Hedge Fund Research Agent*
"""
    return _split_for_telegram(full_report)

def format_advice_output(advice: dict):
    """Turn advisor.py output into Telegram-friendly chunks."""
    if not advice or "symbol" not in advice:
        return ["âš ï¸ Could not generate advice."]

    lines = []
    lines.append("ğŸ§­ **Position Advice**")
    lines.append(f"**Symbol:** {advice['symbol']}")
    lines.append(f"**Entry:** ${advice['entry_price']} | **Last:** ${advice['last_price']}")
    lines.append(f"**Shares:** {advice['shares']} | **Value:** ${advice['position_value']}")
    lines.append(f"**P/L:** ${advice['pnl']} ({advice['pnl_pct']}%) | **Risk:** {advice['risk_level'].title()}")
    lines.append(f"**Sector:** {advice.get('sector','N/A')}")
    lines.append(f"**Decision:** {advice['action']}")

    if advice["action"] in ["DIVERSIFY", "EXIT"]:
        rea = advice.get("reallocation", {})
        lines.append("")
        if advice["action"] == "DIVERSIFY":
            lines.append("ğŸ’¡ **Plan:** Take partial profits and redeploy into diversified, lower-correlation names.")
        else:
            lines.append("ğŸ’¡ **Plan:** Exit position and rotate capital into diversified, quality names.")
        lines.append(f"**Amount to redeploy:** ${rea.get('amount_to_redeploy',0):,.2f}")
        if rea.get("dollar_allocations"):
            lines.append("**Suggested allocations:**")
            for k, v in sorted(rea["dollar_allocations"].items(), key=lambda x: -x[1])[:12]:
                if v > 0:
                    lines.append(f"â€¢ {k}: ${v:,.2f}")
        hedge = advice.get("notes", {}).get("hedge")
        if hedge:
            lines.append(f"ğŸ›¡ï¸ **Hedge note:** {hedge}")
    else:
        hp = advice.get("notes", {}).get("hold_params", {})
        if hp:
            lines.append("")
            lines.append("ğŸ§· **Hold parameters**")
            lines.append(f"Suggested trailing stop: ~{hp.get('suggested_trailing_stop_pct','?')}%")
            lines.append(hp.get("rationale",""))

    rat = advice.get("rationale", {})
    lines.append("")
    lines.append("ğŸ” **Why**")
    lines.append(f"3M Momentum: {rat.get('momentum_3m','?')}% | Recent Min Drawdown: {rat.get('recent_drawdown_min','?')}% | Sector: {rat.get('sector','N/A')}")
    q = rat.get("quality_hint", {})
    lines.append(f"Quality hints â€” P/E: {q.get('pe','?')}, Profit Margin: {q.get('profit_margin','?')}")

    full = "\n".join(lines)
    return _split_for_telegram(full)
